\hypertarget{Almog__Dynamic__Array_8h}{}\doxysection{Almog\+\_\+\+Dynamic\+\_\+\+Array.\+h File Reference}
\label{Almog__Dynamic__Array_8h}\index{Almog\_Dynamic\_Array.h@{Almog\_Dynamic\_Array.h}}


Header-\/only C macros that implement a simple dynamic array.  


{\ttfamily \#include $<$stdlib.\+h$>$}\newline
{\ttfamily \#include $<$assert.\+h$>$}\newline
Include dependency graph for Almog\+\_\+\+Dynamic\+\_\+\+Array.\+h\+:\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=216pt]{Almog__Dynamic__Array_8h__incl}
\end{center}
\end{figure}
This graph shows which files directly or indirectly include this file\+:
\nopagebreak
\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[width=231pt]{Almog__Dynamic__Array_8h__dep__incl}
\end{center}
\end{figure}
\doxysubsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \mbox{\hyperlink{Almog__Dynamic__Array_8h_a85353a3f80faf356276b19a9dfcbbd9e}{ADA\+\_\+\+INIT\+\_\+\+CAPACITY}}~10
\begin{DoxyCompactList}\small\item\em Default initial capacity used by ada\+\_\+init\+\_\+array. \end{DoxyCompactList}\item 
\#define \mbox{\hyperlink{Almog__Dynamic__Array_8h_a541b1d9f14d48a8f62a9540f1ea48f9c}{ADA\+\_\+\+MALLOC}}~malloc
\begin{DoxyCompactList}\small\item\em Allocation function used by this header (defaults to malloc). \end{DoxyCompactList}\item 
\#define \mbox{\hyperlink{Almog__Dynamic__Array_8h_acca05f482336fb7da06934aa3ae4b861}{ADA\+\_\+\+REALLOC}}~realloc
\begin{DoxyCompactList}\small\item\em Reallocation function used by this header (defaults to realloc). \end{DoxyCompactList}\item 
\#define \mbox{\hyperlink{Almog__Dynamic__Array_8h_a724ae18b9292332bc5ba1e889e8244f3}{ADA\+\_\+\+ASSERT}}~assert
\begin{DoxyCompactList}\small\item\em Assertion macro used by this header (defaults to assert). \end{DoxyCompactList}\item 
\#define \mbox{\hyperlink{Almog__Dynamic__Array_8h_aac157302e0837f301f0c915360cfb182}{ada\+\_\+init\+\_\+array}}(type,  header)
\begin{DoxyCompactList}\small\item\em Initialize an array header and allocate its initial storage. \end{DoxyCompactList}\item 
\#define \mbox{\hyperlink{Almog__Dynamic__Array_8h_acecbe7b4a020f5312def063d2a5079cb}{ada\+\_\+resize}}(type,  header,  new\+\_\+capacity)
\begin{DoxyCompactList}\small\item\em Resize the underlying storage to hold new\+\_\+capacity elements. \end{DoxyCompactList}\item 
\#define \mbox{\hyperlink{Almog__Dynamic__Array_8h_a61680400e419e2d55c2e3cb9fe96dad7}{ada\+\_\+appand}}(type,  header,  value)
\begin{DoxyCompactList}\small\item\em Append a value to the end of the array, growing if necessary. \end{DoxyCompactList}\item 
\#define \mbox{\hyperlink{Almog__Dynamic__Array_8h_aeaca809f410cc095f257c1caf9e647a2}{ada\+\_\+insert}}(type,  header,  value,  index)
\begin{DoxyCompactList}\small\item\em Insert value at position index, preserving order (O(n)). \end{DoxyCompactList}\item 
\#define \mbox{\hyperlink{Almog__Dynamic__Array_8h_a0c20741fa11196eb7394b8e05b8e0b48}{ada\+\_\+insert\+\_\+unordered}}(type,  header,  value,  index)
\begin{DoxyCompactList}\small\item\em Insert value at index without preserving order (O(1) amortized). \end{DoxyCompactList}\item 
\#define \mbox{\hyperlink{Almog__Dynamic__Array_8h_a7dd2b8250e6b1be7d5a44ed761c35971}{ada\+\_\+remove}}(type,  header,  index)
\begin{DoxyCompactList}\small\item\em Remove element at index, preserving order (O(n)). \end{DoxyCompactList}\item 
\#define \mbox{\hyperlink{Almog__Dynamic__Array_8h_a0df1461ea637ae0948bd6dd43b5f08ed}{ada\+\_\+remove\+\_\+unordered}}(type,  header,  index)
\begin{DoxyCompactList}\small\item\em Remove element at index by moving the last element into its place (O(1)); order is not preserved. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Header-\/only C macros that implement a simple dynamic array. 

This header provides a minimal, macro-\/based dynamic array for POD-\/like types. The array \char`\"{}header\char`\"{} is a user-\/defined struct with three fields\+:
\begin{DoxyItemize}
\item size\+\_\+t length; current number of elements
\item size\+\_\+t capacity; allocated capacity (in elements)
\item T$\ast$ elements; pointer to contiguous storage of elements (type T)
\end{DoxyItemize}

How to use\+: 1) Define a header struct with length/capacity/elements fields. 2) Initialize it with \mbox{\hyperlink{Almog__Dynamic__Array_8h_aac157302e0837f301f0c915360cfb182}{ada\+\_\+init\+\_\+array(\+T, header)}}. 3) Modify it with ada\+\_\+appand (append), ada\+\_\+insert, remove variants, etc. 4) When done, free(header.\+elements) (or your custom deallocator).

Customization\+:
\begin{DoxyItemize}
\item Define ADA\+\_\+\+MALLOC, ADA\+\_\+\+REALLOC, and ADA\+\_\+\+ASSERT before including this header to override allocation and assertion behavior.
\end{DoxyItemize}

Complexity (n = number of elements)\+:
\begin{DoxyItemize}
\item Append\+: amortized O(1)
\item Ordered insert/remove\+: O(n)
\item Unordered insert/remove\+: O(1)
\end{DoxyItemize}

Notes and limitations\+:
\begin{DoxyItemize}
\item These are macros; arguments may be evaluated multiple times. Pass only simple lvalues (no side effects).
\item Index checks rely on ADA\+\_\+\+ASSERT; with NDEBUG they may be compiled out.
\item ada\+\_\+resize exits the process (exit(1)) if reallocation fails.
\item ada\+\_\+insert reads header.\+elements\mbox{[}header.\+length -\/ 1\mbox{]} internally; inserting into an empty array via ada\+\_\+insert is undefined behavior. Use ada\+\_\+appand or ada\+\_\+insert\+\_\+unordered for that case.
\item No automatic shrinking; you may call ada\+\_\+resize manually.
\end{DoxyItemize}

Example\+: typedef struct \{ size\+\_\+t length; size\+\_\+t capacity; int$\ast$ elements; \} ada\+\_\+int\+\_\+array;

ada\+\_\+int\+\_\+array arr; \mbox{\hyperlink{Almog__Dynamic__Array_8h_aac157302e0837f301f0c915360cfb182}{ada\+\_\+init\+\_\+array(int, arr)}}; \mbox{\hyperlink{Almog__Dynamic__Array_8h_a61680400e419e2d55c2e3cb9fe96dad7}{ada\+\_\+appand(int, arr, 42)}}; \mbox{\hyperlink{Almog__Dynamic__Array_8h_aeaca809f410cc095f257c1caf9e647a2}{ada\+\_\+insert(int, arr, 7, 0)}}; // requires arr.\+length $>$ 0 \mbox{\hyperlink{Almog__Dynamic__Array_8h_a7dd2b8250e6b1be7d5a44ed761c35971}{ada\+\_\+remove(int, arr, 1)}}; free(arr.\+elements); 

Definition in file \mbox{\hyperlink{Almog__Dynamic__Array_8h_source}{Almog\+\_\+\+Dynamic\+\_\+\+Array.\+h}}.



\doxysubsection{Macro Definition Documentation}
\mbox{\Hypertarget{Almog__Dynamic__Array_8h_a61680400e419e2d55c2e3cb9fe96dad7}\label{Almog__Dynamic__Array_8h_a61680400e419e2d55c2e3cb9fe96dad7}} 
\index{Almog\_Dynamic\_Array.h@{Almog\_Dynamic\_Array.h}!ada\_appand@{ada\_appand}}
\index{ada\_appand@{ada\_appand}!Almog\_Dynamic\_Array.h@{Almog\_Dynamic\_Array.h}}
\doxysubsubsection{\texorpdfstring{ada\_appand}{ada\_appand}}
{\footnotesize\ttfamily \#define ada\+\_\+appand(\begin{DoxyParamCaption}\item[{}]{type,  }\item[{}]{header,  }\item[{}]{value }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{        \textcolor{keywordflow}{do} \{                        \(\backslash\)}
\DoxyCodeLine{        if (header.length >= header.capacity) \{                     \(\backslash\)}
\DoxyCodeLine{            ada\_resize(type, header, (\textcolor{keywordtype}{int})(header.capacity*1.5));   \(\backslash\)}
\DoxyCodeLine{        \}                                                           \(\backslash\)}
\DoxyCodeLine{        header.elements[header.length] = value;                     \(\backslash\)}
\DoxyCodeLine{        header.length++;                                            \(\backslash\)}
\DoxyCodeLine{    \} \textcolor{keywordflow}{while} (0)}

\end{DoxyCode}


Append a value to the end of the array, growing if necessary. 


\begin{DoxyParams}{Parameters}
{\em type} & Element type stored in the array. \\
\hline
{\em header} & Lvalue of the header struct. \\
\hline
{\em value} & Value to append.\\
\hline
\end{DoxyParams}
\begin{DoxyPostcond}{Postcondition}
header.\+length is incremented by 1; the last element equals value.
\end{DoxyPostcond}
\begin{DoxyNote}{Note}
Growth factor is (int)(header.\+capacity $\ast$ 1.\+5). Because of truncation, very small capacities may not grow (e.\+g., from 1 to 1). With the default INIT\+\_\+\+CAPACITY=10 this is typically not an issue unless you manually shrink capacity. Ensure growth always increases capacity by at least 1 if you customize this macro. 
\end{DoxyNote}


Definition at line \mbox{\hyperlink{Almog__Dynamic__Array_8h_source_l00169}{169}} of file \mbox{\hyperlink{Almog__Dynamic__Array_8h_source}{Almog\+\_\+\+Dynamic\+\_\+\+Array.\+h}}.

\mbox{\Hypertarget{Almog__Dynamic__Array_8h_a724ae18b9292332bc5ba1e889e8244f3}\label{Almog__Dynamic__Array_8h_a724ae18b9292332bc5ba1e889e8244f3}} 
\index{Almog\_Dynamic\_Array.h@{Almog\_Dynamic\_Array.h}!ADA\_ASSERT@{ADA\_ASSERT}}
\index{ADA\_ASSERT@{ADA\_ASSERT}!Almog\_Dynamic\_Array.h@{Almog\_Dynamic\_Array.h}}
\doxysubsubsection{\texorpdfstring{ADA\_ASSERT}{ADA\_ASSERT}}
{\footnotesize\ttfamily \#define ADA\+\_\+\+ASSERT~assert}



Assertion macro used by this header (defaults to assert). 

Define ADA\+\_\+\+ASSERT before including this file to override. When NDEBUG is defined, standard assert() is disabled. 

Definition at line \mbox{\hyperlink{Almog__Dynamic__Array_8h_source_l00096}{96}} of file \mbox{\hyperlink{Almog__Dynamic__Array_8h_source}{Almog\+\_\+\+Dynamic\+\_\+\+Array.\+h}}.

\mbox{\Hypertarget{Almog__Dynamic__Array_8h_aac157302e0837f301f0c915360cfb182}\label{Almog__Dynamic__Array_8h_aac157302e0837f301f0c915360cfb182}} 
\index{Almog\_Dynamic\_Array.h@{Almog\_Dynamic\_Array.h}!ada\_init\_array@{ada\_init\_array}}
\index{ada\_init\_array@{ada\_init\_array}!Almog\_Dynamic\_Array.h@{Almog\_Dynamic\_Array.h}}
\doxysubsubsection{\texorpdfstring{ada\_init\_array}{ada\_init\_array}}
{\footnotesize\ttfamily \#define ada\+\_\+init\+\_\+array(\begin{DoxyParamCaption}\item[{}]{type,  }\item[{}]{header }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{        \textcolor{keywordflow}{do} \{                                       \(\backslash\)}
\DoxyCodeLine{        header.capacity = \mbox{\hyperlink{Almog__Dynamic__Array_8h_a85353a3f80faf356276b19a9dfcbbd9e}{ADA\_INIT\_CAPACITY}};                                        \(\backslash\)}
\DoxyCodeLine{        header.length = 0;                                                      \(\backslash\)}
\DoxyCodeLine{        header.elements = (type *)\mbox{\hyperlink{Almog__Dynamic__Array_8h_a541b1d9f14d48a8f62a9540f1ea48f9c}{ADA\_MALLOC}}(\textcolor{keyword}{sizeof}(type) * header.capacity);   \(\backslash\)}
\DoxyCodeLine{        ADA\_ASSERT(header.elements != NULL);                                    \(\backslash\)}
\DoxyCodeLine{    \} \textcolor{keywordflow}{while} (0)}

\end{DoxyCode}


Initialize an array header and allocate its initial storage. 


\begin{DoxyParams}{Parameters}
{\em type} & Element type stored in the array (e.\+g., int). \\
\hline
{\em header} & Lvalue of the header struct containing fields\+: length, capacity, and elements.\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
header is a modifiable lvalue; header.\+elements is uninitialized or ignored and will be overwritten. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
header.\+length == 0, header.\+capacity == INIT\+\_\+\+CAPACITY, header.\+elements != NULL (or ADA\+\_\+\+ASSERT fails).
\end{DoxyPostcond}
\begin{DoxyNote}{Note}
Allocation uses ADA\+\_\+\+MALLOC and is checked via ADA\+\_\+\+ASSERT. 
\end{DoxyNote}


Definition at line \mbox{\hyperlink{Almog__Dynamic__Array_8h_source_l00120}{120}} of file \mbox{\hyperlink{Almog__Dynamic__Array_8h_source}{Almog\+\_\+\+Dynamic\+\_\+\+Array.\+h}}.

\mbox{\Hypertarget{Almog__Dynamic__Array_8h_a85353a3f80faf356276b19a9dfcbbd9e}\label{Almog__Dynamic__Array_8h_a85353a3f80faf356276b19a9dfcbbd9e}} 
\index{Almog\_Dynamic\_Array.h@{Almog\_Dynamic\_Array.h}!ADA\_INIT\_CAPACITY@{ADA\_INIT\_CAPACITY}}
\index{ADA\_INIT\_CAPACITY@{ADA\_INIT\_CAPACITY}!Almog\_Dynamic\_Array.h@{Almog\_Dynamic\_Array.h}}
\doxysubsubsection{\texorpdfstring{ADA\_INIT\_CAPACITY}{ADA\_INIT\_CAPACITY}}
{\footnotesize\ttfamily \#define ADA\+\_\+\+INIT\+\_\+\+CAPACITY~10}



Default initial capacity used by ada\+\_\+init\+\_\+array. 

You may override this by defining INIT\+\_\+\+CAPACITY before including this file. 

Definition at line \mbox{\hyperlink{Almog__Dynamic__Array_8h_source_l00064}{64}} of file \mbox{\hyperlink{Almog__Dynamic__Array_8h_source}{Almog\+\_\+\+Dynamic\+\_\+\+Array.\+h}}.

\mbox{\Hypertarget{Almog__Dynamic__Array_8h_aeaca809f410cc095f257c1caf9e647a2}\label{Almog__Dynamic__Array_8h_aeaca809f410cc095f257c1caf9e647a2}} 
\index{Almog\_Dynamic\_Array.h@{Almog\_Dynamic\_Array.h}!ada\_insert@{ada\_insert}}
\index{ada\_insert@{ada\_insert}!Almog\_Dynamic\_Array.h@{Almog\_Dynamic\_Array.h}}
\doxysubsubsection{\texorpdfstring{ada\_insert}{ada\_insert}}
{\footnotesize\ttfamily \#define ada\+\_\+insert(\begin{DoxyParamCaption}\item[{}]{type,  }\item[{}]{header,  }\item[{}]{value,  }\item[{}]{index }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{    \textcolor{keywordflow}{do} \{                                                         \(\backslash\)}
\DoxyCodeLine{    ADA\_ASSERT((\textcolor{keywordtype}{int})(index) >= 0);                                                                          \(\backslash\)}
\DoxyCodeLine{    ADA\_ASSERT((\textcolor{keywordtype}{float})(index) -\/ (\textcolor{keywordtype}{int})(index) == 0);                                                         \(\backslash\)}
\DoxyCodeLine{    ada\_appand(type, header, header.elements[header.length-\/1]);                                             \(\backslash\)}
\DoxyCodeLine{    for (\textcolor{keywordtype}{size\_t} ada\_for\_loop\_index = header.length-\/2; ada\_for\_loop\_index > (index); ada\_for\_loop\_index-\/-\/) \{ \(\backslash\)}
\DoxyCodeLine{        header.elements[ada\_for\_loop\_index] = header.elements [ada\_for\_loop\_index-\/1];                       \(\backslash\)}
\DoxyCodeLine{    \}                                                                                                       \(\backslash\)}
\DoxyCodeLine{    header.elements[(index)] = value;                                                                       \(\backslash\)}
\DoxyCodeLine{\} \textcolor{keywordflow}{while} (0)}

\end{DoxyCode}


Insert value at position index, preserving order (O(n)). 


\begin{DoxyParams}{Parameters}
{\em type} & Element type stored in the array. \\
\hline
{\em header} & Lvalue of the header struct. \\
\hline
{\em value} & Value to insert. \\
\hline
{\em index} & Destination index in the range \mbox{[}0, header.\+length\mbox{]}.\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
0 $<$= index $<$= header.\+length. 

header.\+length $>$ 0 if index == header.\+length (this macro reads the last element internally). For inserting into an empty array, use ada\+\_\+appand or ada\+\_\+insert\+\_\+unordered. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
Element is inserted at index; subsequent elements are shifted right; header.\+length is incremented by 1.
\end{DoxyPostcond}
\begin{DoxyNote}{Note}
This macro asserts index is non-\/negative and an integer value using ADA\+\_\+\+ASSERT. No explicit upper-\/bound assert is performed. 
\end{DoxyNote}


Definition at line \mbox{\hyperlink{Almog__Dynamic__Array_8h_source_l00196}{196}} of file \mbox{\hyperlink{Almog__Dynamic__Array_8h_source}{Almog\+\_\+\+Dynamic\+\_\+\+Array.\+h}}.

\mbox{\Hypertarget{Almog__Dynamic__Array_8h_a0c20741fa11196eb7394b8e05b8e0b48}\label{Almog__Dynamic__Array_8h_a0c20741fa11196eb7394b8e05b8e0b48}} 
\index{Almog\_Dynamic\_Array.h@{Almog\_Dynamic\_Array.h}!ada\_insert\_unordered@{ada\_insert\_unordered}}
\index{ada\_insert\_unordered@{ada\_insert\_unordered}!Almog\_Dynamic\_Array.h@{Almog\_Dynamic\_Array.h}}
\doxysubsubsection{\texorpdfstring{ada\_insert\_unordered}{ada\_insert\_unordered}}
{\footnotesize\ttfamily \#define ada\+\_\+insert\+\_\+unordered(\begin{DoxyParamCaption}\item[{}]{type,  }\item[{}]{header,  }\item[{}]{value,  }\item[{}]{index }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{    \textcolor{keywordflow}{do} \{   \(\backslash\)}
\DoxyCodeLine{    ADA\_ASSERT((\textcolor{keywordtype}{int})(index) >= 0);                              \(\backslash\)}
\DoxyCodeLine{    ADA\_ASSERT((\textcolor{keywordtype}{float})(index) -\/ (\textcolor{keywordtype}{int})(index) == 0);             \(\backslash\)}
\DoxyCodeLine{    if ((\textcolor{keywordtype}{size\_t})(index) == header.length) \{                     \(\backslash\)}
\DoxyCodeLine{        ada\_appand(type, header, value);                        \(\backslash\)}
\DoxyCodeLine{    \} \textcolor{keywordflow}{else} \{                                                    \(\backslash\)}
\DoxyCodeLine{        ada\_appand(type, header, header.elements[(index)]);     \(\backslash\)}
\DoxyCodeLine{        header.elements[(index)] = value;                       \(\backslash\)}
\DoxyCodeLine{    \}                                                           \(\backslash\)}
\DoxyCodeLine{\} \textcolor{keywordflow}{while} (0)}

\end{DoxyCode}


Insert value at index without preserving order (O(1) amortized). 

If index == header.\+length, this behaves like an append. Otherwise, the current element at index is moved to the end, and value is written at index.


\begin{DoxyParams}{Parameters}
{\em type} & Element type stored in the array. \\
\hline
{\em header} & Lvalue of the header struct. \\
\hline
{\em value} & Value to insert. \\
\hline
{\em index} & Index in the range \mbox{[}0, header.\+length\mbox{]}.\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
0 $<$= index $<$= header.\+length. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
header.\+length is incremented by 1; array order is not preserved. 
\end{DoxyPostcond}


Definition at line \mbox{\hyperlink{Almog__Dynamic__Array_8h_source_l00222}{222}} of file \mbox{\hyperlink{Almog__Dynamic__Array_8h_source}{Almog\+\_\+\+Dynamic\+\_\+\+Array.\+h}}.

\mbox{\Hypertarget{Almog__Dynamic__Array_8h_a541b1d9f14d48a8f62a9540f1ea48f9c}\label{Almog__Dynamic__Array_8h_a541b1d9f14d48a8f62a9540f1ea48f9c}} 
\index{Almog\_Dynamic\_Array.h@{Almog\_Dynamic\_Array.h}!ADA\_MALLOC@{ADA\_MALLOC}}
\index{ADA\_MALLOC@{ADA\_MALLOC}!Almog\_Dynamic\_Array.h@{Almog\_Dynamic\_Array.h}}
\doxysubsubsection{\texorpdfstring{ADA\_MALLOC}{ADA\_MALLOC}}
{\footnotesize\ttfamily \#define ADA\+\_\+\+MALLOC~malloc}



Allocation function used by this header (defaults to malloc). 

Define ADA\+\_\+\+MALLOC to a compatible allocator before including this file to override the default. 

Definition at line \mbox{\hyperlink{Almog__Dynamic__Array_8h_source_l00074}{74}} of file \mbox{\hyperlink{Almog__Dynamic__Array_8h_source}{Almog\+\_\+\+Dynamic\+\_\+\+Array.\+h}}.

\mbox{\Hypertarget{Almog__Dynamic__Array_8h_acca05f482336fb7da06934aa3ae4b861}\label{Almog__Dynamic__Array_8h_acca05f482336fb7da06934aa3ae4b861}} 
\index{Almog\_Dynamic\_Array.h@{Almog\_Dynamic\_Array.h}!ADA\_REALLOC@{ADA\_REALLOC}}
\index{ADA\_REALLOC@{ADA\_REALLOC}!Almog\_Dynamic\_Array.h@{Almog\_Dynamic\_Array.h}}
\doxysubsubsection{\texorpdfstring{ADA\_REALLOC}{ADA\_REALLOC}}
{\footnotesize\ttfamily \#define ADA\+\_\+\+REALLOC~realloc}



Reallocation function used by this header (defaults to realloc). 

Define ADA\+\_\+\+REALLOC to a compatible reallocator before including this file to override the default. 

Definition at line \mbox{\hyperlink{Almog__Dynamic__Array_8h_source_l00085}{85}} of file \mbox{\hyperlink{Almog__Dynamic__Array_8h_source}{Almog\+\_\+\+Dynamic\+\_\+\+Array.\+h}}.

\mbox{\Hypertarget{Almog__Dynamic__Array_8h_a7dd2b8250e6b1be7d5a44ed761c35971}\label{Almog__Dynamic__Array_8h_a7dd2b8250e6b1be7d5a44ed761c35971}} 
\index{Almog\_Dynamic\_Array.h@{Almog\_Dynamic\_Array.h}!ada\_remove@{ada\_remove}}
\index{ada\_remove@{ada\_remove}!Almog\_Dynamic\_Array.h@{Almog\_Dynamic\_Array.h}}
\doxysubsubsection{\texorpdfstring{ada\_remove}{ada\_remove}}
{\footnotesize\ttfamily \#define ada\+\_\+remove(\begin{DoxyParamCaption}\item[{}]{type,  }\item[{}]{header,  }\item[{}]{index }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{    \textcolor{keywordflow}{do} \{                                                                \(\backslash\)}
\DoxyCodeLine{    ADA\_ASSERT((\textcolor{keywordtype}{int})(index) >= 0);                                                                          \(\backslash\)}
\DoxyCodeLine{    ADA\_ASSERT((\textcolor{keywordtype}{float})(index) -\/ (\textcolor{keywordtype}{int})(index) == 0);                                                         \(\backslash\)}
\DoxyCodeLine{    for (\textcolor{keywordtype}{size\_t} ada\_for\_loop\_index = (index); ada\_for\_loop\_index < header.length-\/1; ada\_for\_loop\_index++) \{ \(\backslash\)}
\DoxyCodeLine{        header.elements[ada\_for\_loop\_index] = header.elements[ada\_for\_loop\_index+1];                        \(\backslash\)}
\DoxyCodeLine{    \}                                                                                                       \(\backslash\)}
\DoxyCodeLine{    header.length-\/-\/;                                                                                        \(\backslash\)}
\DoxyCodeLine{\} \textcolor{keywordflow}{while} (0)}

\end{DoxyCode}


Remove element at index, preserving order (O(n)). 


\begin{DoxyParams}{Parameters}
{\em type} & Element type stored in the array. \\
\hline
{\em header} & Lvalue of the header struct. \\
\hline
{\em index} & Index in the range \mbox{[}0, header.\+length -\/ 1\mbox{]}.\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
0 $<$= index $<$ header.\+length. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
header.\+length is decremented by 1; subsequent elements are shifted left by one position. The element beyond the new length is left uninitialized. 
\end{DoxyPostcond}


Definition at line \mbox{\hyperlink{Almog__Dynamic__Array_8h_source_l00246}{246}} of file \mbox{\hyperlink{Almog__Dynamic__Array_8h_source}{Almog\+\_\+\+Dynamic\+\_\+\+Array.\+h}}.

\mbox{\Hypertarget{Almog__Dynamic__Array_8h_a0df1461ea637ae0948bd6dd43b5f08ed}\label{Almog__Dynamic__Array_8h_a0df1461ea637ae0948bd6dd43b5f08ed}} 
\index{Almog\_Dynamic\_Array.h@{Almog\_Dynamic\_Array.h}!ada\_remove\_unordered@{ada\_remove\_unordered}}
\index{ada\_remove\_unordered@{ada\_remove\_unordered}!Almog\_Dynamic\_Array.h@{Almog\_Dynamic\_Array.h}}
\doxysubsubsection{\texorpdfstring{ada\_remove\_unordered}{ada\_remove\_unordered}}
{\footnotesize\ttfamily \#define ada\+\_\+remove\+\_\+unordered(\begin{DoxyParamCaption}\item[{}]{type,  }\item[{}]{header,  }\item[{}]{index }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{    \textcolor{keywordflow}{do} \{          \(\backslash\)}
\DoxyCodeLine{    ADA\_ASSERT((\textcolor{keywordtype}{int})(index) >= 0);                              \(\backslash\)}
\DoxyCodeLine{    ADA\_ASSERT((\textcolor{keywordtype}{float})(index) -\/ (\textcolor{keywordtype}{int})(index) == 0);             \(\backslash\)}
\DoxyCodeLine{    header.elements[index] = header.elements[header.length-\/1];  \(\backslash\)}
\DoxyCodeLine{    header.length-\/-\/;                                            \(\backslash\)}
\DoxyCodeLine{\} \textcolor{keywordflow}{while} (0)}

\end{DoxyCode}


Remove element at index by moving the last element into its place (O(1)); order is not preserved. 


\begin{DoxyParams}{Parameters}
{\em type} & Element type stored in the array. \\
\hline
{\em header} & Lvalue of the header struct. \\
\hline
{\em index} & Index in the range \mbox{[}0, header.\+length -\/ 1\mbox{]}.\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
0 $<$= index $<$ header.\+length and header.\+length $>$ 0. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
header.\+length is decremented by 1; array order is not preserved. 
\end{DoxyPostcond}


Definition at line \mbox{\hyperlink{Almog__Dynamic__Array_8h_source_l00267}{267}} of file \mbox{\hyperlink{Almog__Dynamic__Array_8h_source}{Almog\+\_\+\+Dynamic\+\_\+\+Array.\+h}}.

\mbox{\Hypertarget{Almog__Dynamic__Array_8h_acecbe7b4a020f5312def063d2a5079cb}\label{Almog__Dynamic__Array_8h_acecbe7b4a020f5312def063d2a5079cb}} 
\index{Almog\_Dynamic\_Array.h@{Almog\_Dynamic\_Array.h}!ada\_resize@{ada\_resize}}
\index{ada\_resize@{ada\_resize}!Almog\_Dynamic\_Array.h@{Almog\_Dynamic\_Array.h}}
\doxysubsubsection{\texorpdfstring{ada\_resize}{ada\_resize}}
{\footnotesize\ttfamily \#define ada\+\_\+resize(\begin{DoxyParamCaption}\item[{}]{type,  }\item[{}]{header,  }\item[{}]{new\+\_\+capacity }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{        \textcolor{keywordflow}{do} \{                                                         \(\backslash\)}
\DoxyCodeLine{        type *ada\_temp\_pointer = (type *)\mbox{\hyperlink{Almog__Dynamic__Array_8h_acca05f482336fb7da06934aa3ae4b861}{ADA\_REALLOC}}((\textcolor{keywordtype}{void} *)(header.elements), new\_capacity*\textcolor{keyword}{sizeof}(type)); \(\backslash\)}
\DoxyCodeLine{        if (ada\_temp\_pointer == NULL) \{                                                                     \(\backslash\)}
\DoxyCodeLine{            exit(1);                                                                                        \(\backslash\)}
\DoxyCodeLine{        \}                                                                                                   \(\backslash\)}
\DoxyCodeLine{        header.elements = ada\_temp\_pointer;                                                                 \(\backslash\)}
\DoxyCodeLine{        ADA\_ASSERT(header.elements != NULL);                                                                \(\backslash\)}
\DoxyCodeLine{        header.capacity = new\_capacity;                                                                     \(\backslash\)}
\DoxyCodeLine{    \} \textcolor{keywordflow}{while} (0)}

\end{DoxyCode}


Resize the underlying storage to hold new\+\_\+capacity elements. 


\begin{DoxyParams}{Parameters}
{\em type} & Element type stored in the array. \\
\hline
{\em header} & Lvalue of the header struct. \\
\hline
{\em new\+\_\+capacity} & New capacity in number of elements.\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
new\+\_\+capacity $>$= header.\+length (otherwise elements beyond new\+\_\+capacity are lost and length will not be adjusted). 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
header.\+capacity == new\+\_\+capacity and header.\+elements points to a block large enough for new\+\_\+capacity elements.
\end{DoxyPostcond}
\begin{DoxyWarning}{Warning}
On allocation failure, this macro calls exit(1). 
\end{DoxyWarning}
\begin{DoxyNote}{Note}
Reallocation uses ADA\+\_\+\+REALLOC and is also checked via ADA\+\_\+\+ASSERT. 
\end{DoxyNote}


Definition at line \mbox{\hyperlink{Almog__Dynamic__Array_8h_source_l00143}{143}} of file \mbox{\hyperlink{Almog__Dynamic__Array_8h_source}{Almog\+\_\+\+Dynamic\+\_\+\+Array.\+h}}.

