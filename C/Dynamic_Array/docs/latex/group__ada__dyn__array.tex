\hypertarget{group__ada__dyn__array}{}\doxysection{ADA Dynamic Array Macros}
\label{group__ada__dyn__array}\index{ADA Dynamic Array Macros@{ADA Dynamic Array Macros}}


Macros to manage a simple dynamic array.  


\doxysubsection*{Macros}
\begin{DoxyCompactItemize}
\item 
\#define \mbox{\hyperlink{group__ada__dyn__array_ga85353a3f80faf356276b19a9dfcbbd9e}{ADA\+\_\+\+INIT\+\_\+\+CAPACITY}}~10
\begin{DoxyCompactList}\small\item\em Default initial capacity used by ada\+\_\+init\+\_\+array. \end{DoxyCompactList}\item 
\#define \mbox{\hyperlink{group__ada__dyn__array_ga541b1d9f14d48a8f62a9540f1ea48f9c}{ADA\+\_\+\+MALLOC}}~malloc
\begin{DoxyCompactList}\small\item\em Allocation function used by this header (defaults to malloc). \end{DoxyCompactList}\item 
\#define \mbox{\hyperlink{group__ada__dyn__array_gacca05f482336fb7da06934aa3ae4b861}{ADA\+\_\+\+REALLOC}}~realloc
\begin{DoxyCompactList}\small\item\em Reallocation function used by this header (defaults to realloc). \end{DoxyCompactList}\item 
\#define \mbox{\hyperlink{group__ada__dyn__array_ga724ae18b9292332bc5ba1e889e8244f3}{ADA\+\_\+\+ASSERT}}~assert
\begin{DoxyCompactList}\small\item\em Assertion macro used by this header (defaults to assert). \end{DoxyCompactList}\item 
\#define \mbox{\hyperlink{group__ada__dyn__array_gaac157302e0837f301f0c915360cfb182}{ada\+\_\+init\+\_\+array}}(type,  header)
\begin{DoxyCompactList}\small\item\em Initialize an array header and allocate its initial storage. \end{DoxyCompactList}\item 
\#define \mbox{\hyperlink{group__ada__dyn__array_gacecbe7b4a020f5312def063d2a5079cb}{ada\+\_\+resize}}(type,  header,  new\+\_\+capacity)
\begin{DoxyCompactList}\small\item\em Resize the underlying storage to hold new\+\_\+capacity elements. \end{DoxyCompactList}\item 
\#define \mbox{\hyperlink{group__ada__dyn__array_ga61680400e419e2d55c2e3cb9fe96dad7}{ada\+\_\+appand}}(type,  header,  value)
\begin{DoxyCompactList}\small\item\em Append a value to the end of the array, growing if necessary. \end{DoxyCompactList}\item 
\#define \mbox{\hyperlink{group__ada__dyn__array_gaeaca809f410cc095f257c1caf9e647a2}{ada\+\_\+insert}}(type,  header,  value,  index)
\begin{DoxyCompactList}\small\item\em Insert value at position index, preserving order (O(n)). \end{DoxyCompactList}\item 
\#define \mbox{\hyperlink{group__ada__dyn__array_ga0c20741fa11196eb7394b8e05b8e0b48}{ada\+\_\+insert\+\_\+unordered}}(type,  header,  value,  index)
\begin{DoxyCompactList}\small\item\em Insert value at index without preserving order (O(1) amortized). \end{DoxyCompactList}\item 
\#define \mbox{\hyperlink{group__ada__dyn__array_ga7dd2b8250e6b1be7d5a44ed761c35971}{ada\+\_\+remove}}(type,  header,  index)
\begin{DoxyCompactList}\small\item\em Remove element at index, preserving order (O(n)). \end{DoxyCompactList}\item 
\#define \mbox{\hyperlink{group__ada__dyn__array_ga0df1461ea637ae0948bd6dd43b5f08ed}{ada\+\_\+remove\+\_\+unordered}}(type,  header,  index)
\begin{DoxyCompactList}\small\item\em Remove element at index by moving the last element into its place (O(1)); order is not preserved. \end{DoxyCompactList}\end{DoxyCompactItemize}


\doxysubsection{Detailed Description}
Macros to manage a simple dynamic array. 



\doxysubsection{Macro Definition Documentation}
\mbox{\Hypertarget{group__ada__dyn__array_ga61680400e419e2d55c2e3cb9fe96dad7}\label{group__ada__dyn__array_ga61680400e419e2d55c2e3cb9fe96dad7}} 
\index{ADA Dynamic Array Macros@{ADA Dynamic Array Macros}!ada\_appand@{ada\_appand}}
\index{ada\_appand@{ada\_appand}!ADA Dynamic Array Macros@{ADA Dynamic Array Macros}}
\doxysubsubsection{\texorpdfstring{ada\_appand}{ada\_appand}}
{\footnotesize\ttfamily \#define ada\+\_\+appand(\begin{DoxyParamCaption}\item[{}]{type,  }\item[{}]{header,  }\item[{}]{value }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{        \textcolor{keywordflow}{do} \{                        \(\backslash\)}
\DoxyCodeLine{        if (header.length >= header.capacity) \{                     \(\backslash\)}
\DoxyCodeLine{            ada\_resize(type, header, (\textcolor{keywordtype}{int})(header.capacity*1.5));   \(\backslash\)}
\DoxyCodeLine{        \}                                                           \(\backslash\)}
\DoxyCodeLine{        header.elements[header.length] = value;                     \(\backslash\)}
\DoxyCodeLine{        header.length++;                                            \(\backslash\)}
\DoxyCodeLine{    \} \textcolor{keywordflow}{while} (0)}

\end{DoxyCode}


Append a value to the end of the array, growing if necessary. 


\begin{DoxyParams}{Parameters}
{\em type} & Element type stored in the array. \\
\hline
{\em header} & Lvalue of the header struct. \\
\hline
{\em value} & Value to append.\\
\hline
\end{DoxyParams}
\begin{DoxyPostcond}{Postcondition}
header.\+length is incremented by 1; the last element equals value.
\end{DoxyPostcond}
\begin{DoxyNote}{Note}
Growth factor is (int)(header.\+capacity $\ast$ 1.\+5). Because of truncation, very small capacities may not grow (e.\+g., from 1 to 1). With the default INIT\+\_\+\+CAPACITY=10 this is typically not an issue unless you manually shrink capacity. Ensure growth always increases capacity by at least 1 if you customize this macro. 
\end{DoxyNote}


Definition at line \mbox{\hyperlink{Almog__Dynamic__Array_8h_source_l00176}{176}} of file \mbox{\hyperlink{Almog__Dynamic__Array_8h_source}{Almog\+\_\+\+Dynamic\+\_\+\+Array.\+h}}.

\mbox{\Hypertarget{group__ada__dyn__array_ga724ae18b9292332bc5ba1e889e8244f3}\label{group__ada__dyn__array_ga724ae18b9292332bc5ba1e889e8244f3}} 
\index{ADA Dynamic Array Macros@{ADA Dynamic Array Macros}!ADA\_ASSERT@{ADA\_ASSERT}}
\index{ADA\_ASSERT@{ADA\_ASSERT}!ADA Dynamic Array Macros@{ADA Dynamic Array Macros}}
\doxysubsubsection{\texorpdfstring{ADA\_ASSERT}{ADA\_ASSERT}}
{\footnotesize\ttfamily \#define ADA\+\_\+\+ASSERT~assert}



Assertion macro used by this header (defaults to assert). 

Define ADA\+\_\+\+ASSERT before including this file to override. When NDEBUG is defined, standard assert() is disabled. 

Definition at line \mbox{\hyperlink{Almog__Dynamic__Array_8h_source_l00103}{103}} of file \mbox{\hyperlink{Almog__Dynamic__Array_8h_source}{Almog\+\_\+\+Dynamic\+\_\+\+Array.\+h}}.

\mbox{\Hypertarget{group__ada__dyn__array_gaac157302e0837f301f0c915360cfb182}\label{group__ada__dyn__array_gaac157302e0837f301f0c915360cfb182}} 
\index{ADA Dynamic Array Macros@{ADA Dynamic Array Macros}!ada\_init\_array@{ada\_init\_array}}
\index{ada\_init\_array@{ada\_init\_array}!ADA Dynamic Array Macros@{ADA Dynamic Array Macros}}
\doxysubsubsection{\texorpdfstring{ada\_init\_array}{ada\_init\_array}}
{\footnotesize\ttfamily \#define ada\+\_\+init\+\_\+array(\begin{DoxyParamCaption}\item[{}]{type,  }\item[{}]{header }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{        \textcolor{keywordflow}{do} \{                                       \(\backslash\)}
\DoxyCodeLine{        header.capacity = \mbox{\hyperlink{group__ada__dyn__array_ga85353a3f80faf356276b19a9dfcbbd9e}{ADA\_INIT\_CAPACITY}};                                        \(\backslash\)}
\DoxyCodeLine{        header.length = 0;                                                      \(\backslash\)}
\DoxyCodeLine{        header.elements = (type *)\mbox{\hyperlink{group__ada__dyn__array_ga541b1d9f14d48a8f62a9540f1ea48f9c}{ADA\_MALLOC}}(\textcolor{keyword}{sizeof}(type) * header.capacity);   \(\backslash\)}
\DoxyCodeLine{        ADA\_ASSERT(header.elements != NULL);                                    \(\backslash\)}
\DoxyCodeLine{    \} \textcolor{keywordflow}{while} (0)}

\end{DoxyCode}


Initialize an array header and allocate its initial storage. 


\begin{DoxyParams}{Parameters}
{\em type} & Element type stored in the array (e.\+g., int). \\
\hline
{\em header} & Lvalue of the header struct containing fields\+: length, capacity, and elements.\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
header is a modifiable lvalue; header.\+elements is uninitialized or ignored and will be overwritten. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
header.\+length == 0, header.\+capacity == INIT\+\_\+\+CAPACITY, header.\+elements != NULL (or ADA\+\_\+\+ASSERT fails).
\end{DoxyPostcond}
\begin{DoxyNote}{Note}
Allocation uses ADA\+\_\+\+MALLOC and is checked via ADA\+\_\+\+ASSERT. 
\end{DoxyNote}


Definition at line \mbox{\hyperlink{Almog__Dynamic__Array_8h_source_l00127}{127}} of file \mbox{\hyperlink{Almog__Dynamic__Array_8h_source}{Almog\+\_\+\+Dynamic\+\_\+\+Array.\+h}}.

\mbox{\Hypertarget{group__ada__dyn__array_ga85353a3f80faf356276b19a9dfcbbd9e}\label{group__ada__dyn__array_ga85353a3f80faf356276b19a9dfcbbd9e}} 
\index{ADA Dynamic Array Macros@{ADA Dynamic Array Macros}!ADA\_INIT\_CAPACITY@{ADA\_INIT\_CAPACITY}}
\index{ADA\_INIT\_CAPACITY@{ADA\_INIT\_CAPACITY}!ADA Dynamic Array Macros@{ADA Dynamic Array Macros}}
\doxysubsubsection{\texorpdfstring{ADA\_INIT\_CAPACITY}{ADA\_INIT\_CAPACITY}}
{\footnotesize\ttfamily \#define ADA\+\_\+\+INIT\+\_\+\+CAPACITY~10}



Default initial capacity used by ada\+\_\+init\+\_\+array. 

You may override this by defining INIT\+\_\+\+CAPACITY before including this file. 

Definition at line \mbox{\hyperlink{Almog__Dynamic__Array_8h_source_l00071}{71}} of file \mbox{\hyperlink{Almog__Dynamic__Array_8h_source}{Almog\+\_\+\+Dynamic\+\_\+\+Array.\+h}}.

\mbox{\Hypertarget{group__ada__dyn__array_gaeaca809f410cc095f257c1caf9e647a2}\label{group__ada__dyn__array_gaeaca809f410cc095f257c1caf9e647a2}} 
\index{ADA Dynamic Array Macros@{ADA Dynamic Array Macros}!ada\_insert@{ada\_insert}}
\index{ada\_insert@{ada\_insert}!ADA Dynamic Array Macros@{ADA Dynamic Array Macros}}
\doxysubsubsection{\texorpdfstring{ada\_insert}{ada\_insert}}
{\footnotesize\ttfamily \#define ada\+\_\+insert(\begin{DoxyParamCaption}\item[{}]{type,  }\item[{}]{header,  }\item[{}]{value,  }\item[{}]{index }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{    \textcolor{keywordflow}{do} \{                                                         \(\backslash\)}
\DoxyCodeLine{    ADA\_ASSERT((\textcolor{keywordtype}{int})(index) >= 0);                                                                          \(\backslash\)}
\DoxyCodeLine{    ADA\_ASSERT((\textcolor{keywordtype}{float})(index) -\/ (\textcolor{keywordtype}{int})(index) == 0);                                                         \(\backslash\)}
\DoxyCodeLine{    ada\_appand(type, header, header.elements[header.length-\/1]);                                             \(\backslash\)}
\DoxyCodeLine{    for (\textcolor{keywordtype}{size\_t} ada\_for\_loop\_index = header.length-\/2; ada\_for\_loop\_index > (index); ada\_for\_loop\_index-\/-\/) \{ \(\backslash\)}
\DoxyCodeLine{        header.elements[ada\_for\_loop\_index] = header.elements [ada\_for\_loop\_index-\/1];                       \(\backslash\)}
\DoxyCodeLine{    \}                                                                                                       \(\backslash\)}
\DoxyCodeLine{    header.elements[(index)] = value;                                                                       \(\backslash\)}
\DoxyCodeLine{\} \textcolor{keywordflow}{while} (0)}

\end{DoxyCode}


Insert value at position index, preserving order (O(n)). 


\begin{DoxyParams}{Parameters}
{\em type} & Element type stored in the array. \\
\hline
{\em header} & Lvalue of the header struct. \\
\hline
{\em value} & Value to insert. \\
\hline
{\em index} & Destination index in the range \mbox{[}0, header.\+length\mbox{]}.\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
0 $<$= index $<$= header.\+length. 

header.\+length $>$ 0 if index == header.\+length (this macro reads the last element internally). For inserting into an empty array, use ada\+\_\+appand or ada\+\_\+insert\+\_\+unordered. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
Element is inserted at index; subsequent elements are shifted right; header.\+length is incremented by 1.
\end{DoxyPostcond}
\begin{DoxyNote}{Note}
This macro asserts index is non-\/negative and an integer value using ADA\+\_\+\+ASSERT. No explicit upper-\/bound assert is performed. 
\end{DoxyNote}


Definition at line \mbox{\hyperlink{Almog__Dynamic__Array_8h_source_l00203}{203}} of file \mbox{\hyperlink{Almog__Dynamic__Array_8h_source}{Almog\+\_\+\+Dynamic\+\_\+\+Array.\+h}}.

\mbox{\Hypertarget{group__ada__dyn__array_ga0c20741fa11196eb7394b8e05b8e0b48}\label{group__ada__dyn__array_ga0c20741fa11196eb7394b8e05b8e0b48}} 
\index{ADA Dynamic Array Macros@{ADA Dynamic Array Macros}!ada\_insert\_unordered@{ada\_insert\_unordered}}
\index{ada\_insert\_unordered@{ada\_insert\_unordered}!ADA Dynamic Array Macros@{ADA Dynamic Array Macros}}
\doxysubsubsection{\texorpdfstring{ada\_insert\_unordered}{ada\_insert\_unordered}}
{\footnotesize\ttfamily \#define ada\+\_\+insert\+\_\+unordered(\begin{DoxyParamCaption}\item[{}]{type,  }\item[{}]{header,  }\item[{}]{value,  }\item[{}]{index }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{    \textcolor{keywordflow}{do} \{   \(\backslash\)}
\DoxyCodeLine{    ADA\_ASSERT((\textcolor{keywordtype}{int})(index) >= 0);                              \(\backslash\)}
\DoxyCodeLine{    ADA\_ASSERT((\textcolor{keywordtype}{float})(index) -\/ (\textcolor{keywordtype}{int})(index) == 0);             \(\backslash\)}
\DoxyCodeLine{    if ((\textcolor{keywordtype}{size\_t})(index) == header.length) \{                     \(\backslash\)}
\DoxyCodeLine{        ada\_appand(type, header, value);                        \(\backslash\)}
\DoxyCodeLine{    \} \textcolor{keywordflow}{else} \{                                                    \(\backslash\)}
\DoxyCodeLine{        ada\_appand(type, header, header.elements[(index)]);     \(\backslash\)}
\DoxyCodeLine{        header.elements[(index)] = value;                       \(\backslash\)}
\DoxyCodeLine{    \}                                                           \(\backslash\)}
\DoxyCodeLine{\} \textcolor{keywordflow}{while} (0)}

\end{DoxyCode}


Insert value at index without preserving order (O(1) amortized). 

If index == header.\+length, this behaves like an append. Otherwise, the current element at index is moved to the end, and value is written at index.


\begin{DoxyParams}{Parameters}
{\em type} & Element type stored in the array. \\
\hline
{\em header} & Lvalue of the header struct. \\
\hline
{\em value} & Value to insert. \\
\hline
{\em index} & Index in the range \mbox{[}0, header.\+length\mbox{]}.\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
0 $<$= index $<$= header.\+length. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
header.\+length is incremented by 1; array order is not preserved. 
\end{DoxyPostcond}


Definition at line \mbox{\hyperlink{Almog__Dynamic__Array_8h_source_l00229}{229}} of file \mbox{\hyperlink{Almog__Dynamic__Array_8h_source}{Almog\+\_\+\+Dynamic\+\_\+\+Array.\+h}}.

\mbox{\Hypertarget{group__ada__dyn__array_ga541b1d9f14d48a8f62a9540f1ea48f9c}\label{group__ada__dyn__array_ga541b1d9f14d48a8f62a9540f1ea48f9c}} 
\index{ADA Dynamic Array Macros@{ADA Dynamic Array Macros}!ADA\_MALLOC@{ADA\_MALLOC}}
\index{ADA\_MALLOC@{ADA\_MALLOC}!ADA Dynamic Array Macros@{ADA Dynamic Array Macros}}
\doxysubsubsection{\texorpdfstring{ADA\_MALLOC}{ADA\_MALLOC}}
{\footnotesize\ttfamily \#define ADA\+\_\+\+MALLOC~malloc}



Allocation function used by this header (defaults to malloc). 

Define ADA\+\_\+\+MALLOC to a compatible allocator before including this file to override the default. 

Definition at line \mbox{\hyperlink{Almog__Dynamic__Array_8h_source_l00081}{81}} of file \mbox{\hyperlink{Almog__Dynamic__Array_8h_source}{Almog\+\_\+\+Dynamic\+\_\+\+Array.\+h}}.

\mbox{\Hypertarget{group__ada__dyn__array_gacca05f482336fb7da06934aa3ae4b861}\label{group__ada__dyn__array_gacca05f482336fb7da06934aa3ae4b861}} 
\index{ADA Dynamic Array Macros@{ADA Dynamic Array Macros}!ADA\_REALLOC@{ADA\_REALLOC}}
\index{ADA\_REALLOC@{ADA\_REALLOC}!ADA Dynamic Array Macros@{ADA Dynamic Array Macros}}
\doxysubsubsection{\texorpdfstring{ADA\_REALLOC}{ADA\_REALLOC}}
{\footnotesize\ttfamily \#define ADA\+\_\+\+REALLOC~realloc}



Reallocation function used by this header (defaults to realloc). 

Define ADA\+\_\+\+REALLOC to a compatible reallocator before including this file to override the default. 

Definition at line \mbox{\hyperlink{Almog__Dynamic__Array_8h_source_l00092}{92}} of file \mbox{\hyperlink{Almog__Dynamic__Array_8h_source}{Almog\+\_\+\+Dynamic\+\_\+\+Array.\+h}}.

\mbox{\Hypertarget{group__ada__dyn__array_ga7dd2b8250e6b1be7d5a44ed761c35971}\label{group__ada__dyn__array_ga7dd2b8250e6b1be7d5a44ed761c35971}} 
\index{ADA Dynamic Array Macros@{ADA Dynamic Array Macros}!ada\_remove@{ada\_remove}}
\index{ada\_remove@{ada\_remove}!ADA Dynamic Array Macros@{ADA Dynamic Array Macros}}
\doxysubsubsection{\texorpdfstring{ada\_remove}{ada\_remove}}
{\footnotesize\ttfamily \#define ada\+\_\+remove(\begin{DoxyParamCaption}\item[{}]{type,  }\item[{}]{header,  }\item[{}]{index }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{    \textcolor{keywordflow}{do} \{                                                                \(\backslash\)}
\DoxyCodeLine{    ADA\_ASSERT((\textcolor{keywordtype}{int})(index) >= 0);                                                                          \(\backslash\)}
\DoxyCodeLine{    ADA\_ASSERT((\textcolor{keywordtype}{float})(index) -\/ (\textcolor{keywordtype}{int})(index) == 0);                                                         \(\backslash\)}
\DoxyCodeLine{    for (\textcolor{keywordtype}{size\_t} ada\_for\_loop\_index = (index); ada\_for\_loop\_index < header.length-\/1; ada\_for\_loop\_index++) \{ \(\backslash\)}
\DoxyCodeLine{        header.elements[ada\_for\_loop\_index] = header.elements[ada\_for\_loop\_index+1];                        \(\backslash\)}
\DoxyCodeLine{    \}                                                                                                       \(\backslash\)}
\DoxyCodeLine{    header.length-\/-\/;                                                                                        \(\backslash\)}
\DoxyCodeLine{\} \textcolor{keywordflow}{while} (0)}

\end{DoxyCode}


Remove element at index, preserving order (O(n)). 


\begin{DoxyParams}{Parameters}
{\em type} & Element type stored in the array. \\
\hline
{\em header} & Lvalue of the header struct. \\
\hline
{\em index} & Index in the range \mbox{[}0, header.\+length -\/ 1\mbox{]}.\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
0 $<$= index $<$ header.\+length. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
header.\+length is decremented by 1; subsequent elements are shifted left by one position. The element beyond the new length is left uninitialized. 
\end{DoxyPostcond}


Definition at line \mbox{\hyperlink{Almog__Dynamic__Array_8h_source_l00253}{253}} of file \mbox{\hyperlink{Almog__Dynamic__Array_8h_source}{Almog\+\_\+\+Dynamic\+\_\+\+Array.\+h}}.

\mbox{\Hypertarget{group__ada__dyn__array_ga0df1461ea637ae0948bd6dd43b5f08ed}\label{group__ada__dyn__array_ga0df1461ea637ae0948bd6dd43b5f08ed}} 
\index{ADA Dynamic Array Macros@{ADA Dynamic Array Macros}!ada\_remove\_unordered@{ada\_remove\_unordered}}
\index{ada\_remove\_unordered@{ada\_remove\_unordered}!ADA Dynamic Array Macros@{ADA Dynamic Array Macros}}
\doxysubsubsection{\texorpdfstring{ada\_remove\_unordered}{ada\_remove\_unordered}}
{\footnotesize\ttfamily \#define ada\+\_\+remove\+\_\+unordered(\begin{DoxyParamCaption}\item[{}]{type,  }\item[{}]{header,  }\item[{}]{index }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{    \textcolor{keywordflow}{do} \{          \(\backslash\)}
\DoxyCodeLine{    ADA\_ASSERT((\textcolor{keywordtype}{int})(index) >= 0);                              \(\backslash\)}
\DoxyCodeLine{    ADA\_ASSERT((\textcolor{keywordtype}{float})(index) -\/ (\textcolor{keywordtype}{int})(index) == 0);             \(\backslash\)}
\DoxyCodeLine{    header.elements[index] = header.elements[header.length-\/1];  \(\backslash\)}
\DoxyCodeLine{    header.length-\/-\/;                                            \(\backslash\)}
\DoxyCodeLine{\} \textcolor{keywordflow}{while} (0)}

\end{DoxyCode}


Remove element at index by moving the last element into its place (O(1)); order is not preserved. 


\begin{DoxyParams}{Parameters}
{\em type} & Element type stored in the array. \\
\hline
{\em header} & Lvalue of the header struct. \\
\hline
{\em index} & Index in the range \mbox{[}0, header.\+length -\/ 1\mbox{]}.\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
0 $<$= index $<$ header.\+length and header.\+length $>$ 0. 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
header.\+length is decremented by 1; array order is not preserved. 
\end{DoxyPostcond}


Definition at line \mbox{\hyperlink{Almog__Dynamic__Array_8h_source_l00274}{274}} of file \mbox{\hyperlink{Almog__Dynamic__Array_8h_source}{Almog\+\_\+\+Dynamic\+\_\+\+Array.\+h}}.

\mbox{\Hypertarget{group__ada__dyn__array_gacecbe7b4a020f5312def063d2a5079cb}\label{group__ada__dyn__array_gacecbe7b4a020f5312def063d2a5079cb}} 
\index{ADA Dynamic Array Macros@{ADA Dynamic Array Macros}!ada\_resize@{ada\_resize}}
\index{ada\_resize@{ada\_resize}!ADA Dynamic Array Macros@{ADA Dynamic Array Macros}}
\doxysubsubsection{\texorpdfstring{ada\_resize}{ada\_resize}}
{\footnotesize\ttfamily \#define ada\+\_\+resize(\begin{DoxyParamCaption}\item[{}]{type,  }\item[{}]{header,  }\item[{}]{new\+\_\+capacity }\end{DoxyParamCaption})}

{\bfseries Value\+:}
\begin{DoxyCode}{0}
\DoxyCodeLine{        \textcolor{keywordflow}{do} \{                                                         \(\backslash\)}
\DoxyCodeLine{        type *ada\_temp\_pointer = (type *)\mbox{\hyperlink{group__ada__dyn__array_gacca05f482336fb7da06934aa3ae4b861}{ADA\_REALLOC}}((\textcolor{keywordtype}{void} *)(header.elements), new\_capacity*\textcolor{keyword}{sizeof}(type)); \(\backslash\)}
\DoxyCodeLine{        if (ada\_temp\_pointer == NULL) \{                                                                     \(\backslash\)}
\DoxyCodeLine{            exit(1);                                                                                        \(\backslash\)}
\DoxyCodeLine{        \}                                                                                                   \(\backslash\)}
\DoxyCodeLine{        header.elements = ada\_temp\_pointer;                                                                 \(\backslash\)}
\DoxyCodeLine{        ADA\_ASSERT(header.elements != NULL);                                                                \(\backslash\)}
\DoxyCodeLine{        header.capacity = new\_capacity;                                                                     \(\backslash\)}
\DoxyCodeLine{    \} \textcolor{keywordflow}{while} (0)}

\end{DoxyCode}


Resize the underlying storage to hold new\+\_\+capacity elements. 


\begin{DoxyParams}{Parameters}
{\em type} & Element type stored in the array. \\
\hline
{\em header} & Lvalue of the header struct. \\
\hline
{\em new\+\_\+capacity} & New capacity in number of elements.\\
\hline
\end{DoxyParams}
\begin{DoxyPrecond}{Precondition}
new\+\_\+capacity $>$= header.\+length (otherwise elements beyond new\+\_\+capacity are lost and length will not be adjusted). 
\end{DoxyPrecond}
\begin{DoxyPostcond}{Postcondition}
header.\+capacity == new\+\_\+capacity and header.\+elements points to a block large enough for new\+\_\+capacity elements.
\end{DoxyPostcond}
\begin{DoxyWarning}{Warning}
On allocation failure, this macro calls exit(1). 
\end{DoxyWarning}
\begin{DoxyNote}{Note}
Reallocation uses ADA\+\_\+\+REALLOC and is also checked via ADA\+\_\+\+ASSERT. 
\end{DoxyNote}


Definition at line \mbox{\hyperlink{Almog__Dynamic__Array_8h_source_l00150}{150}} of file \mbox{\hyperlink{Almog__Dynamic__Array_8h_source}{Almog\+\_\+\+Dynamic\+\_\+\+Array.\+h}}.

